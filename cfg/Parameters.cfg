#!/usr/bin/env python3

PACKAGE = "pcl_interface"

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

# Define parameters
# gen.add("pcd_filepath", str_t, "X", "Input point cloud file path")
# gen.add("output_pcd_filepath", str_t, "/", "Output point cloud file path")

gen.add("downsample_leaf_size", double_t, 0, "Leaf size for downsampling", 0.01, 0, 0.1)
gen.add("kmeans_cluster_size", int_t, 0, "Number of clusters for KMeans clustering", 2, 1, 10)
gen.add("visualization_point_size", int_t, 0, "Size of points for visualization", 3, 0, 10)

# SAC Parameters    
sac_params = gen.add_group("sac_params")
sac_params.add("optimize_coefficients", bool_t, 0, "Optimize coefficients for SAC", True)
sac_params.add("model_type", int_t, 0, "SAC model type", 0, 0, 20)
sac_params.add("method_type", int_t, 0, "SAC method type", 0, 0, 20)
sac_params.add("max_iterations", int_t, 0, "Maximum iterations for SAC", 100, 0, 1000)
sac_params.add("distance_threshold", double_t, 0, "Distance threshold for SAC", 0.01, 0, 1)
sac_params.add("filtering", bool_t, 0, "Enable filtering for SAC", True)
sac_params.add("min_indices", int_t, 0, "Minimum indices for SAC", 200, 0, 1000)
sac_params.add("is_cloud_clustered", bool_t, 0, "Is cloud clustered for SAC", False)
sac_params.add("normal_axis_X", double_t, 0, "Normal axis for SAC (X)", 0 ,0, 1)
sac_params.add("normal_axis_Y", double_t, 0, "Normal axis for SAC (Y)", 0, 0, 1)
sac_params.add("normal_axis_Z", double_t, 0, "Normal axis for SAC (Z)", 1, 0, 1)
sac_params.add("angle_threshold", double_t, 0, "Angle threshold for SAC",10.0 , 0 , 90)


# Cluster SAC Parameters
cluster_sac_params = gen.add_group("cluster_sac_params")
cluster_sac_params.add("cluster_optimize_coefficients", bool_t, 0, "Optimize coefficients for Cluster SAC", True)
cluster_sac_params.add("cluster_model_type", int_t, 0, "Cluster SAC model type", 15, 0, 20)
cluster_sac_params.add("cluster_method_type", int_t, 0, "Cluster SAC method type", 0, 0, 20)
cluster_sac_params.add("cluster_distance_threshold", double_t, 0, "Distance threshold for Cluster SAC", 0.02 , 0 , 0.1)
cluster_sac_params.add("cluster_max_iterations", int_t, 0, "Maximum iterations for Cluster SAC",500, 1, 1000)
cluster_sac_params.add("cluster_filtering", bool_t, 0, "Enable filtering for Cluster SAC", False)
cluster_sac_params.add("cluster_min_indices", int_t, 0, "Minimum indices for Cluster SAC", 200 , 1 , 1000)
cluster_sac_params.add("cluster_is_cloud_clustered", bool_t, 0, "Is cloud clustered for Cluster SAC",True)
cluster_sac_params.add("cluster_normal_axis_X", double_t, 0, "Normal axis for SAC (X)", 0, 0, 1,)
cluster_sac_params.add("cluster_normal_axis_Y", double_t, 0, "Normal axis for SAC (Y)", 0, 0, 1,)
cluster_sac_params.add("cluster_normal_axis_Z", double_t, 0, "Normal axis for SAC (Z)", 1, 0, 1,)
cluster_sac_params.add("cluster_angle_threshold", double_t, 0, "Angle threshold for Cluster SAC", 10.0, 0, 90)


# Region Growing Parameters
region_growing_params = gen.add_group("region_growing_params")
region_growing_params.add("rg_min_cluster_size", int_t, 0, "Minimum cluster size for region growing", 50 , 0, 1000)
region_growing_params.add("rg_max_cluster_size", int_t, 0, "Maximum cluster size for region growing", 25000 , 0, 1000000)
region_growing_params.add("rg_number_of_neighbours", int_t, 0, "Number of neighbors for region growing", 30, 0, 100)
region_growing_params.add("rg_distance_threshold", double_t, 0, "Distance threshold for region growing", 1.0, 0, 10)
region_growing_params.add("rg_point_color_threshold", double_t, 0, "Point color threshold for region growing", 6.0, 0, 10)
region_growing_params.add("rg_region_color_threshold", double_t, 0, "Region color threshold for region growing", 5.0, 0, 10)
region_growing_params.add("rg_smoothness_threshold", double_t, 0, "Smoothness threshold for region growing", 3.0, 0, 10)
region_growing_params.add("rg_curvature_threshold", double_t, 0, "Curvature threshold for region growing", 1.0, 0, 10)

# Euclidean Cluster Extraction Parameters
ec_params = gen.add_group("ec_params")
ec_params.add("ec_cluster_tolerance", double_t, 0, "Cluster tolerance for Euclidean Cluster Extraction", 0.015, 0, 0.1)
ec_params.add("ec_min_cluster_size", int_t, 0, "Minimum cluster size for Euclidean Cluster Extraction", 200, 0, 1000)
ec_params.add("ec_max_cluster_size", int_t, 0, "Maximum cluster size for Euclidean Cluster Extraction", 25000, 0, 1000000)

# Passthrough Filter
passthrough_filter = gen.add_group("passthrough_filter")
passthrough_filter.add("x_limit_min", double_t, 0, "Minimum limit for X axis", -3.0, -10, 10)
passthrough_filter.add("x_limit_max", double_t, 0, "Maximum limit for X axis", 3.0, -10, 10)
passthrough_filter.add("y_limit_min", double_t, 0, "Minimum limit for Y axis", -3.0, -10, 10)
passthrough_filter.add("y_limit_max", double_t, 0, "Maximum limit for Y axis", 2.0, -10, 10)
passthrough_filter.add("z_limit_min", double_t, 0, "Minimum limit for Z axis", -2.0, -10, 10)
passthrough_filter.add("z_limit_max", double_t, 0, "Maximum limit for Z axis", 1.0, -10, 10)

# Conditional Removal
conditional_removal = gen.add_group("conditional_removal")
conditional_removal.add("conditional_z_limit_min", double_t, 0.0, "Minimum limit for Z axis",0 , 0, 1)
conditional_removal.add("conditional_z_limit_max", double_t, 0.8, "Maximum limit for Z axis", 0.8, 0, 1) 


# Statistical Outlier Removal Parameters
statistical_outlier_removal = gen.add_group("statistical_outlier_removal")
statistical_outlier_removal.add("sor_mean_k", int_t, 0, "Mean k for Statistical Outlier Removal", 50, 0, 1000)
statistical_outlier_removal.add("sor_stddev_mul_thresh", double_t, 0, "Standard deviation multiplier threshold for Statistical Outlier Removal", 1.0, 0, 10)
# Radius Outlier Removal Parameters
radius_outlier_removal = gen.add_group("radius_outlier_removal")
radius_outlier_removal.add("ror_radius_search", double_t, 0, "Radius search for Radius Outlier Removal", 0.01, 0, 1)
radius_outlier_removal.add("ror_min_neighbors_in_radius", int_t, 0, "Minimum neighbors in radius for Radius Outlier Removal", 50, 0, 1000)
radius_outlier_removal.add("ror_keep_organized", bool_t, 0, "Keep organized for Radius Outlier Removal", True)

exit(gen.generate(PACKAGE, "pcl_interface_node", "Parameters"))
